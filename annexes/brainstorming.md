# Archives des idées du Brainstorming
+ Les éléments ensuite renotés dans la définition au propre du projet ou abandonnés seront rayés
+ Les raisons de l'abandon d'éléments seront expliquées à la fin du document de plannification du projet

~~appli flash card + culture generale~~
~~Actions (version mobile):~~

- ~~tap affiche une card~~
- ~~swipe haut : affiche le menu de la carte ?~~
- ~~swipe bas si ne sait pas, tap again affiche la reponse,~~
- ~~swipe left false,~~
- ~~swipe right true~~
- ~~menu sur la gauche en desktop~~
- ~~Pour des raisons d'accessibilité attention avec les swaps, ils doivent pouvoir etre utilisé par un controle à la voix ? si ça marche comme ça ? à voir~~

- ~~utiliser ses propres flashcard et déterminer soi même si on a bon ou pas,~~
- ~~ou utiliser des flashcards prefaites et devoir taper la réponse (validation avec des mots clés), ou qcm,~~
  - ~~permettrait de faire des classements d'utiliser des flashcards faites par la communauté~~
  - ~~idée de classement ou de carte avec validation automatique des réponses abandonnée -> cela inciterais à penser un système de validation des cartes, alors qu'il est plus intellignet et rapide de laisser l'utilisateur valider lui meme la carte,, pour l'utilisateur cela lui permet de juste swiper sans avoir a taper de reponses, ce qui est mieux quand il est sur son mobile (cas principal d'utilisation, et qu'il n'a pas beaucoup de temps-> il est dans le bus par exmple, ou entre deux rendez-vous,...), en ce qui concerne d'éventuels compétitions (qui nécessiterais forcément de valider les reponses par l'appli, pour que tout le mond esoit a égalité et que personnne ne puisse tricher,) cela poserait problème dans le sens ou cela casse une parti de l'objectif des flashcards, qui sont normalement des outils pour apprendre , personnelement et chacun à son rythme, créer des concours semble etre typiquement une mauvaise idée créant inutilement un esprit de compétition qui n'a pas lieu d'etre, brainscape utilise un système de compétition intéressant, puisqu'ils mettent en compétition le nombre de cartes jouées et non le taux de réussite, ce qui incite les gens à tenter de faire plsu de cartes, sans se mettre la pressionen se disant qu'ils sont moins bon que les autres -> idée de compétition à éviter qaund même: l'objectif est vraiment d'avoir une app utilisable pour n'importe quel type de flashcard , et donc laisser un maximum d'amplitude à l'utilisateur, s'il est en effet moins efficace de faire des applis trop génériques, et qu'il vaut généralemnent mieux se concentrer sur un type en particulier, ici le but est d'avoir justement une app qui fonctionne dans la grande majorité des cas, de façon à ce qu'un utilisateur qui souhaite créer des cartes différentes dans le style (du genre langages, etcartes géographiques), puisse le faire sans avoir besoin de deux applis différentes. L'outil doit donc etre suffisamment maléable pour laissser les utilisateurs créer des cartes de styles très différents (un peu comme pour des mods pour un jeu vidéo où les devs créent un outil de base solide, et les moddeurs peuvent alors créer toute sorte de mods très différents en focntion de ce qu'ils veulent)-> _mdr gé pa lu_~~

* ~~possibilité d'utiliser les cartes de la communauté sans compte, si on veut créer, ou avoir des stats il faut un compte, sans compte on peut juste tester des cartes de manière random sans que l'appli ne retienne nos scores~~

* ~~types de flashcards:~~

  - ~~Mot <-> description/image~~
  - ~~image <-> description~~
  - ~~concept <-> schéma (**advanced**:réalisable directment sur l'appli ?)~~
  - ~~QCM -> réponse (pas vraiment d'intéret à laisser l'utilisateur choisir le sens d'apprentissage)~~
  - ~~**advanced**: audio (ex: mot de langue étrangère) <-> prononciation phonétique/description/traduction (ex: d'un coté un mot audio, de l'autre sa version écrite, afin de travailler sa prononciation)~~

* ~~Ajouter une option de dessin ?  permettrait à ceux qui apprennent des langues dans un autre alphabet que le leur de répondre en dessinant le caractère puis de comparer leur dessin avec la réponse, leur évitant d'avoir une feuille à coté, (pratique quand on est dns le bus)-> pourrait etre une option avancé, puisque ce système serait légèrement différent, en effet dans tous les autres cas la réponse de l'utilisateur a juste besoin d'etre dans sa tête, là il y aurait un dessin , donc pour la réponse il faut prévoir un espace pour la réponse et un espace pour le dessin/ecriture de l'utilisateur (mais faisable avec des outils de canvas comme celui utilisé sur skribbl par exemple), s'il y a option de dessin il faudrait que ça désactive le swipe des cartes ?~~
- ~~l'espace de dessin peut etre sur la carte en entier (un peu à la façon des flashcards pleco)~~

* ~~Pour la création des flashcards on pourrait avoir des templates en fonction du type de flashcard ou de la famille de flash cards (exemple les cartes de langues pourraient avoir mot <-> définition/prononciation )~~

* ~~on peut créer des catégories de cartes (ex: mandarin, formules mathématiques,..)~~

* ~~En plus des cartes qu'on peut créer pour la communauté on peut créer des decks/collections de cartes, qui pourront aussi etre notés par la communauté ou triés par popularité, ainsi si on ne veut pas créer soit meme une collection de cartes culture générale, on peut prendre une collection, les collections pourraient etre nommés et contenr des sous collections, permettant ainsi d'avoir des séries (par exemple collection: `apprendre l'arabe`, sous collection `1.1 - Les bases`, `1.2 - L'écriture`, ...), les collections doivent de base avoir le meme genre de cartes (puisqu'il s'agit des groupes utilisables pour une session d'apprentissage) autrement on ne pourrait pas choisir quoi montrer si par exemple on a une carte qui a ``prononciation+signification <=> caractère`` et une autre ``signification <=> règle de grammaire``, on ne pourrait alors pas choisir dans les paramètres ce qui est affiché sur les cartes, si on souhaite faire des collections génériques (qui peuvent donc cumuler toutes les cartes qu'on veut, c'est possible mais il faut alors garder l'affichage par défaut de la carte, on ne peut alors choiir que d'affciher le recto ou le verso lors de la session et pas les options qu'on met dessus)~~

* ~~Pour les collections, indiquer la progression par des graphs (rang de la carte, taux de réussite)~~

* ~~Quand on crée une carte on peut choisir de mettre plusieurs éléments sur un seul coté, (exemple prononciation + caractère), et il faut choisir quels éléments sont choisis par défaut (tous ceux ajoutés ?, seulement une partie)~~

* ~~Dans les options il faut pouvoir customiser l'aspect visuel des cartes (couleurs de font, police, couleur du texte, disposition des éléments de réponses)~~

* ~~Créer un système de réclamation et de signalement, si on s'aperçoit que des cartes ont un problème (infos erronées, insultantes, pas dans la bonne catégorie, du genre astrologie dans la famille science lol, (ou géologie), on peut en premier lieu contacter l'auteur de la carte s'il est toujoours présent sur le site, pour signaler l'erreur; si ce n'est plus possible on peut les signaler, les cartes signalées pourraient:~~
  - ~~etre gérées directement par la communauté (lorsqu'une carte est signalée, la communauté peut voter pour déterminer si la carte pose en effet problème ou non, on peut alors choisir d'exclure totalemnt la carte, ou d'y ajouter un avertissement) -> problème, s'il n'y a pas assez d'utilisaeur, soit le système est inutilisable soit il est dangereux (avec des signalements rendus possibles par une minorité capable de nuire au système, exemple virer des cartes juste pour le fun; si beaucoup de personnes, rien n'empêche techniquement un raid organisé (peu probable, mais à prendre en compte tout de même)~~
  - ~~etre gérée par des modérateurs -> problèmes: nécessite une équipe, fiabilité de l'équipe ?~~

* ~~Créer un systèm de notes, on peut noter les cartes de la communauté :soit note globale sur 10 points/5 demi étoiles, soit notes divisées: justesse de la carte (l'info est elle vraie ?), efficacité de la carte (est elle bien rédigé, pas d'infos superflu, on peut la lire rapidement), on pourrait aussi utiliser la popularité des cartes (combien d'utilisateurs les utilisent dans leur "deck", ou combien de fois elles ont été utilisés dans des sessions d'apprentissage)~~

* ~~Les familles de cartes sont au dessus des catégories et sous catégories, elles sont définies par le site et sont les grands groupes d'apprentissage: langue, géographie, histoire, culture générale,...~~

* ~~Faire un systme de succès pour encourager les gens à apprendre des cartes~~

- ~~Idées logo:~~
  - ~~Cartes stylisées, logo double sens flash (la forme des cartes peut éoquer à la fois des cartes ou un éclair)~~

~~utiliser un linter ?~~

~~express.js pour node en mode web~~
~~sequelize pour l'ORM~~

~~stimulus si on fait avec laravel~~
~~vue/react -> pas obligatirmenet de bdd~~

~~pour le projet vue en front ? , node en back ? voir Strapi ?~~

~~export -> electron (desktop)/capacitor (mobile)~~

~~faire une todo en test pour tester vue front~~

~~docker:~~
1. ~~outiller le projet : bdd avec docker par exemple~~
2. ~~utiliser docker compose meme sur un projet unique~~
3. ~~mariaDB adminer~~
~~En dernier tenter carrément de run le projet sur docker~~

* ~~Possibilité de planifier des sessions d'apprentissage (exemple tous les mercredis à 13h avoir une notif de rappel pour une séance de cartes)~~

* ~~niveaux de difficultés:~~
  - ~~facile~~
  - ~~moyen~~
  - ~~difficile~~
  - ~~custom (non disponible pour les cartes qu'on crée pour la communauté, ou alors il faudrait ajouter en plus du nom de la difficulté une estimation de la position de cette difficulté par rapport aux autres)~~
  - ~~Il pourrait etre déterminé: soit par l'auteur, soit automatiquement en fonction de notre taux de réussite par rapport au nombre d'essai (exempple une carte qu'on a faite 20 fois avec seulement 30% de taux de réussite, est clairement une carte difficile en revanche une carte faite uniquement 3 fois, si elle a un taux de réussite de 33%, cela signifie simplement qu'on l'a réussi une fois et échoué deux fois, mais elle n'a pas été faite beaucoup de fois, donc peut etre que seulement deux essais de plus porterait son score à 80% dans ce cas la le taux de réussite seul , n'est pas un bon indicateur de la difficulté, à voir donc comment prendre en compte les deux éléments)~~

+ ~~Pour les éléments sur les cartes peut etre utilisé un système de checksum par exemple si dans la bdd pour une carte on a 2items au recto 3 au verso elle a une checksum qui dépend de ces items, une autre carte meme si elle a le meme nombre d'items (2 et 3) pourrait ne pas avoir la meme checksum car cela dépendra du nom des items (exemple peut etre quelque chose du genre traduction_prononciation) => problème: qu'arrive-t-il si l'utilisateur ne rentre pas a chaque fois els élements dans le meme ordre ? exemple un coup ol met prononciation puis trduction et l'autre coup il inverse, solution => utiliser l'ordre alphabétique, ainsi peut importe l'ordre dans lequel il met il y aura toujours le meme ordre (ici prononciation_traduction) pour la checksum, pour contrecarrer les problème d'utilisateur qui n'écrivent pas les items de la meme façon à chaque fois on pourrait avoir un select qui permettrait de choisir les types d'items déjà utilisé (exemple "traduction", "caractère"), pour les collections il pourrait aussi y avoir la possibilité de créer des cartes au sein d'une collection, ainsi le template de cartes nous afficherait toutes les options présentes  sur ce type de carte, ne marcherait pas pour les collections génériques du coup ?~~ 

* ~~Possibilité de choisir une priorité d'apprentissage: quand c'est la première fois qu'on passe sur une carte le système pourrait ne pas la reproposer avant longtemps ou la reproposer dans peu de temps, mais peut etre que l'utilisateur pourrait estimer que ça il sait mieux que la carte précédente (qu'il connait aussi mais estime moins la connaitre), il faudrait peut etre avoir un système qui permet à l'utilisateur de déterminer la priorité d'apprendtissage de la carte (entre deux cartes réussies au cours d'une session, laquelle il connait le mieux, entre deux échouées laquelle il connait le moins bien), cela pourrait consister à ajouter un niveau de priorité (lié à la difficulté): plusieurs possibilités:~~
  - ~~Inspiré de brainscape: une jauge, qui permet à l'utilsateur de définir à quel point il pense connaitre ou non la réponse~~
  - ~~Inspiré de pleco: un niveau de priorité (sur la carte ou dans les paramètres de la carte) qui peut etre changé ou définit automatiquement~~
  - ~~Optimal, une sorte de mélange des deux, le mieux est d'éviter à l'utilisateur d'avoir à faire ça à chaque fois, il faudrait que la priorité d'apprentissage soit majoritairement automatique en fonction de la difficulté, du taux de réussite, ..., peut etre créer une option de calbrage: l'utilisateur pourrait choisir d'ajouter à ses sessions (notamment lorsqu'il utilises un set de cartes pour la première fois) une jauge ou autre moyen de graduer sa réussite, idées diverses:~~
    - ~~la direction dans laquelle il swap pour valider pourrait déterminer la difficulté, exemple en haut très bien réussi, à droite comme d'hab réussie, en bas largement echouée (priorité haute), à gauche échouée -> problème , peut etre pas très intuitif, et facile de se rater en swipant, (alors que juste gauche/droite façon appli de rencontre, c'est plus simple et plus intuitif)~~
    - ~~une simple option prioritaire à cocher/sélectionner, ensuite en fonction du sens dans lequel on swipe cela rend: soit la carte plus prioritaire si on l'a échouée, soit moins importante si on a réussi~~
    - ~~Une option choix multiples haute priorité/basse priorité, avant de swiper pour valider~~
    - ~~Une jauge sur 3 ou 5 niveaux d'assurance~~
    - ~~Utiliser le sytème des rangs, cela permettrait de passer la carte au rang supérieur, cela ne gère qu'en parti la priorité automatique de la carte, mais permet quand même à l'utilisateur de choisir à quel niveau il pense connaitre cette carte, (si elle est à un niveau élevé c'est qu'il la connait bien, et donc dans le cas ou il fait une session générale sans rang particulier cette carte pourrait apparaitre moins ? ou le simple faite qu'elle ai un rang permet à l'utilisateur de choisir lui meme quelle rang de carte il veut lors de l'apprentissage) -> idée: A coté de l'indication du rang actuel, un plus et un moins pour augmenter le rang ou le réduire si besoin, à la création des cartes on peut leur attribuer un rang déjà élevé si on estime déjà les connaitre bien~~
    - ~~La jauge de rang pourrait avoir : les chiffres de 1 à 5, l'indiaction du nom du rang actuel au dessus (qui changerait si on change le rang)~~

* ~~¨Possibilité de sauvegarder les cartes hors ligne pour la version appli mobile ? -> qu'est ce que ça implique pour la bdd ? , il faut donc que cela soit stocké sur l'appareil de l'utilisateur~~
* ~~Possibilité d'importer des cartes en JSON ou autre format, ou des données via une API, à voir ce que cela implique en terme de sécurité pour l'appli ?~~
* ~~Possibilité d'exporter des cartes ? Intérêt à voir ?, si elles sont uniquement utilisable sur le site/appli, c'est sans doute pas très utiles, à voir peut etre: une option pour convertir en version imprimable ?~~

* ~~Pour les infos que l'utilisateur doit avoir, tâcher d'etre le plus efficace possible, phrases courtes et efficaces, avec si besoin un lien vers une aide plus détaillée, plutot qu'un pavé de texte directment~~

* ~~dans les paramètres on peut choisir la fréquence des cartes:~~
  - ~~quand une carte est sue (quand on a swipé pour la valider), un timer lui est ajouté pour déterminer dans combien de temps l'appli nous représentera la carte, ce time pourrait fonctionner de la manière suivante:~~
    - ~~On notifie quel est la position de la carte (exemple c'est la 536eme carte qu'on apprend), le "timer" définit dans combien de cartes on pourra la reproposer, au lancement d'une session si il y assez de cartes, l'appli ne choisira pas cette carte si on a pas encore atteint le "time" (ex: c'était la 536eme carte, le timer avait définit qu'on ne devait pas la revoir avant 40 cartes, donc si on en est actuellement à la 556eme carte il ne devrait pas la reproposer car il faut qu'il attende la 576eme carte, je pense qu'il est mieux de ne pas se soucier du nombre de cartes qu'il y aura dans la session, par exemple si on avait une session de 100 cartes techiniquement on atteindrait cette 576eme carte au bout de la 20eme denotre session dans cet exemple néanmoins cela complexifierais le calcul inutilement et poserais problème , en effet vu que les cartes sont définis aléatoirement avant la session, celle ci risquerait d'apparaitre avant le temps imparti, ce qui pourrait ne pas etre un problème mais pourrait aussi le devenir dans le cas ou l'utilsiateur a souvent tendance à ne jamais finir ses sessions)~~
  - ~~ce timer est également imapcté en fonction du niveau de succès de la carte:~~
    - ~~cela est déterminé par les réglages, on peut ajouter un niveau de difficulté au cartes, et déterminer un réglage de temps e fonction de ce niveau:~~
    - ~~exemple une carte niveau facile si elle est sue une première fois ne réapparaitra que au bout de 20 jours la toute première fois, au bout de 20 jours si on réussi encore, la carte obtient alors un taux de réussite qui est de 100% (il faut minimum deux passages sur une carte pour qu'elle commence a avoir un taux de réussite ), avec ce taux elle sera alors représentée dans 30jours (créer une formule qui prend en compte le temps en fonction du niveau de difficulté et du taux de réussite)~~
  - ~~Le timer pourrait aussi fonctionner avec un temps Unix~~

* ~~Créer un système de _rang_ (nom à changer ?), en plus des catégories/sous-catégories et niveaux de difficultés on peut choisir au sein d'une meme catégorie des rangs, les rangs permettent de se laisser de la souplesse sur la valdation des réponses par exemple rang 1 on peut ne connaitre qu'une partie de la réponse alors qu'un rang 5 nécessite la réponse exacte (laissée à l'appréciation de l'utilisateur), , par exmple pour du mandarin on pourrait avoir un rang de base `mot anglais` <-> `mot mandarin écrit/prononciation/Tons`, les cartes lorsqu'elles sont rangées au rang 1, peuvent etre considérées valides juste si on a le bon mot, peu mporte le ton et l'écriture, au rang 2 il faudrait en plus etre capable de connaitre le ton des mots, puis finalement de savoir l'écirre cela permettrait sur des notions avancées, d'avoir une progression, la personne pourrait choisir de déjà maitriser les traductions, avant de se soucier des prononciations puis de l'écriture/orthographe correcte (puiqu'il faudrait qu'il sache en premier comment dire ce mot, avant de se soucier de la prnonciation exacte ou de l'ortographe), dans les options on peut choisir au bout de combien de fois, un mot réussi dans un rang doit automatiquement passer au rang supérieur (laisser une possibilité de le mettre manuellement ?), exemple quand l'utilisateur a réussi (voir entre nombre de carte réussies d'affilés-> préférable dans ce cas afin de voir plutot en fonction de sa progression récente plutot que de la réussie globale, ou en fonction du taux de réussite ?) 3 fois de suite ou a un taux de réussite de 75% sur une carte alors celle ci peut passer au rang supérieur -> l'idée des rangs pourrait etre abandonnée s'il n'y a pas assez de cas dans lesquels cela pourrait etre utile( en géographie on pourrait avoir le nom d'un pays et au verso, la population, langue parlée, superficie,..., ainsi l'utilisateur pourrait avoir un rang quand il connait la langue parlée, un autre quand il connait la superficie et la langue parlée, un dernier quand il connait tous les éléments)~~
* ~~Ajouter une option pour rétrogader ou promouvoir automatiquement une carte après un certain nombre (réglable) d'échecs ou de réussite, en plus de laisser l'utilisdateur le faire manuellement~~
* ~~Les rangs sont nomable et pourraient soit etre pratiqués individuellement exemple: session de cartes rangs 3, soit mélangées quelquesoit le rang et dans ce cas avoir le rang marqué au dessus de la réponse pour indique à l'utilisateur quel sévérité il peut utiliser pour valider ou on la carte), le rang pourrait etre changeable en cours de validation, exempleune fois la réponse affichée, si la carte est en rang 1 (ex:juste définition) et qu'on estime que on sait aussi la prononciation et l'écrit alors on peut la passer au rang supérieur (select ? / Jauge ?)~~

* ~~Paramètres d'une session d'apprentissage:~~
~~Quand on lance une session on choisit d'abord la collection, afin de déterminer si elle est éligible au changement d'affichage des éléments (c'est à dire si toutes les cartes ont le même **format**), sinon on ne pourra choisir qu'entre recto ou verso~~
  - ~~famille de carte~~
  - ~~catégorie et/ou sous-catégorie~~
  - ~~difficulté des cartes (toutes, facile, moyen, difficile)~~
  - ~~rang des cartes (si elles en ont: tous les rangs, rang 1, 2 jusqu'à 5 ou nombre custom ?)~~
  - ~~nombre de cartes à apprendre/ou chronomètre avec objectif maximum de cartes dans un certain temps (utile ?)~~
  - ~~Si en mode nombre de cartes , option pour chronométrer le temps passé ?~~
  - ~~Notes (quand on utilise des cartes de la communauté on peut les filtrer en fonction de leur note/popularité)~~
  - ~~quelle partie de la carte on montre (recto ou verso, si un des côtés possèdent plusieurs infos, laquelle montrer ? juste la prononciation, prononciation et écriture ?....)~~

* ~~Recto et verso peuvent avoir plusieurs éléments -> voir au niveau bdd si du coup on stock le contenu recto et verso ou si on stock plutot des types de réponses (définition, description, prononciation, formule, image, qcm, schéma,...) et on choisit ensuite ce que l'on souhaite afficher sur la carte ? à voir car ce ne serait pas la meme chose si on prend des cartes communautaires ou perso -> problème si on a des cartes communautaires avec les types description et image, et d'autres schéma et formule , comment on choisit ça dans les paramètres de session ?, il faudrait que l'option pour changer ce qu'on affiche sur les cartes ne soit dispo que pour les cartes d'un meme type, le mieux serait donc que par défaut on a juste question sur recto/ réponse sur verso, ensuite on peut créer des types de cartes avancées (certains patterns déjà tout fait existeront par exemple pour les langues ou la géographie), sur lesquels on choisit les différents éléments (ex: nom du pays, drapeau, population, langue), toutes les cartes suivant ce modèle ne peuvent que etre mélangés avec des cartes suivant le meme modèle (collection de carte), ou alors des cartes génériques mais à ce moment là on ne peut ps sélectionner les éléments affichables ou non (on pourra ainsi tout de meme utiliser nos cartes dans une collection générique, et afficher toutes les infos)~~

* ~~Mode flashcard auto ? : si on souhaite apprendre quelquechose ou la création de flash cards serait longue et fastidieuse (exemple vérifier qu'on sait calculer du binaiore rapidement), il pourrait dans ce cas y avoir des listes auto (vu que les cartes ne sont pas sauvegardés les stats ne fonctionneraient pas du coup ?), l'appli envoie à chaque fois un nombre et la réponse en binaire, pour se tester, soit il y aurait des types de listespréfaites, comment construit on ces cartes ?:~~ 
  - ~~on pourrait avoir des séries auto-préfaites (exemple pour le binaire, donc codé en dur dans l'appli),~~ 
  - ~~ou alors la possibilité pour l'utilisateur de créer des règles qui régissent ces cartes auto (exemple s'il veut une série de carte pour la table du 11, il pourrait choisir pour règle les nombres entre 0 et 100 * 11)~~
  - ~~une importation depuis du JSON (mais cela pourrait aussi etre utilisé pour simplement créer des séries de cartes)~~ 

* ~~statistiques et données des cartes:~~

  - ~~Générales et personnelles:~~
    - ~~Contenu du recto (plusieurs éléments ?)~~
    - ~~Contenu du verso (plusieurs éléments ?)~~
    - ~~difficulté de la carte~~
    - ~~Rangs possibles et rang actuel~~
    - ~~Famille~~
    - ~~Catégorie~~
    - ~~Note sur le site globale (si partagée)~~
    - ~~Popularité globale (si partagée)~~
  - ~~Propre à une carte de l'utilisateur:~~
    - ~~rang actuel de la carte~~
    - ~~Nombre de passage sur la carte~~
    - ~~taux de réussite~~
    - ~~priorité de la carte~~: ~~calculée en fonction du rang, du nombre de passage, du taux de réussite/difficulté, elle permet d'ajuster le **timer (nom à changer)** et de savoir au bout de combien de temps la carte doit être reproposé, en gros si une carte à un taux de réussite élevé, un rang élevé (indiquant que l'utilisateur ne la maitrise correctement) et un nombre de passage élevé, alors le taux de priorité sera faible, à l'inverse si la carte est souvent échouée , n'a que peu de fois été réalisée et si son rang est faible indiquant que l'utilisateur n'estime pas la maitriser correctement alors le taux de priorité sera élevé~~
  - ~~Propre à l'utilisateur:~~
    - ~~Taux de réussite globale~~
    - ~~Cartes pratiquées par jour~~
    - ~~difficulté globale des cartes réussi (créer un score en fonction de la difficulté et du taux de réussite ?)~~

* ~~Pour le design du site~~
  - ~~on épure au maximum~~
  - ~~Il faut que les sessions soit le plus accessible possible:~~
    - ~~Options de base préparamétrées, l'utilisateur n'a plus qu'à choisir une catégorie/famille et il peut lancer,~~
    - ~~quand il a lancé une fois, cela garde ses paramètres en mémoire donc quand il lance l'app ou le site il peut en un clic relancer sa session en cours ou en lancer une nouvelle (un peu commme un bouton continuer la partie), un autre bouton peut lui permettre de changer les réglages avant d elancer une nouvelle série~~
  - ~~une page de presentation de ce que sont les falshcard et pourquoi on peut les utiliser (peut servir pour le référencement)~~
  - ~~un tuto simplifié la première fois qu'on utilise (on peut sauter le tuto), ne pas faire un tuto frustrant avec une fenetre qui pop toutes les deux secondes, mais plutot quelque chose d'épuré et de très simple(ex: swipe à droite pour une carte acceptée, ...), par exemple cela pourrait être une session de flashcards avec les tutos à la place des cartes ?~~
  - ~~commencer par la version mobile~~
  - ~~Menu à gauche~~
  - ~~Faire un schéma des différentes parties et interactions possibles, afin de voir par exmeple en combien de clics on arrive au menu, aux options, on lance une session,...~~
  - ~~Possibilité de se connecter avec un compte (genre réseau social, google,...) ?~~



+ ~~Quand on arrive sur la page créer une collection: ~~
  - ~~Si on vient depuis le lien créer une collection publique le champ rendre public est coché (on peut néanmoins décocher si finalement on veut une collection privée)~~
  -~~ Si on vient depuis le lien créer une collection ~~
  ~~|-> ou alors on fait un seul lien pour créer les collections et le champs public/privé est cochable ou non~~


BDD:
- ~~il faut un maximum de 4 éléments par carte (c'est largement suffisant)~~
- ~~on crée une table pour les libellés d'éléments (pour une collection donnée, on a les libellés qui lui sont liés)~~
- ~~le champ qui indique le format par défaut de la collection pour le recto verso stocke une liste de numéros, il y a meme deux champs, un verso qui indiques les éléments par défaut dans le verso et un recto idem, donc par exemple: recto: [1,2] verso [3] -> c=voir plutôt deuxième idée ;~~
- ~~autre idée pour stocker les valeurs par défaut recto/verso, on pourrait stocker un simple nombre plutôt qu'une array (peut etre mieux pour les perfs ?) -> exemple le premier champ élément d'une carte possède le nombre des unités ``0001``, le deuxième champ est une dizaine ``0020``, le 3eme une centaine ``0300`` et le 4ème le millier: ``4000`` donc par exemple pour un recto: 4 et 1 avec un verso 2;on pourrait avoir ``4001`` et ``0200`` dans deux colonnes ou peut etre même dans une seule avec un nombre à virgule par exemple: ``4001.0200`` est-ce vraiment mieux niveau perf ? comment on récupère l'info facilement après sur l'app ? formule mathématique ?~~ 
- ~~OU alors même concept que just au dessus mais en binaire ? parce que du coup si on a juste besoin de la position du nombre ce sera toujours la meme, par exemple: 4001, si à la place j'écris 1001 (9) ce sera aussi compréhensible , on aurait donc ``0001``, ``0010``, ``0100`` et ``1000`` et on pourrait alors recomposer , est ce que dans ce cas ça serait pas mieux de stocker directement le chiffre corrspondant ? ce serait plus simple pour la vérif, on stockerait 1 pour le 1er champ, 2 pour le deuxième, 4 pour le 3eme et 8 pour le 4eme et on pourrait alors composer, stocker 12 dans verso indique qu'on a le 3eme et le 4eme dans le verso, si on veut on peut même faire: 4 premiers bits = éléments au recto, 4 derniers =éléments au verso, comme ça on stocke tout dans une colonne: donc si on stocke ``1001 0100`` (148): cela signifie qu'on a le 4eme et le premier élément au recto par défaut, le 3 eme au verso, et le 2eme quin'est pas montré sur la config de défaut , on pourrait peut etre aussi stocker les codes des possibilités, exemple: 148, 20, ... ensuite quand on doit récupérer l'affichage par défaut on analyse le nombre binaire comme si c'était une chaine:~~
- ~~pour l'élément 1: si string(0) = 1 alors elem1 est au recto, si string(4) = 1 alors elem1 au verso si aucun des deux = 1 alors elem1 n'apparait pas sur l'affichage par défaut, et ainsi de suite (cette méthode serait normalement plus efficace que de faire un switch case finalement du genre 148= 4 et 1 au recto et 3 au verso), parce qu'avec 4 éléments et la possibilité d'en afficher entre minimum 2, maximum 4 soit au recto soit au verso, et qu'il en faille minimum 1 de chaque côté (donc 0000 0000 est interdit des deux côtés et 1111 impossible car cela forcerait 0000 de l'autre côté) on a: 14 possibilités de placement à gauche: dont:~~
  - ~~4 avec 1 carte -> chacune des 3 cartes restantes a 3 positions possibles si on ne met qu'une carte, 2 si on en met 2, et 1 si on en met 3ce qui fait donc 6 combinaisons~~
  - ~~6 avec 2 cartes -> chacune des 2 cartes restantes a 2 positions possible restante si on en met q'une et une seule position si on en met 2 ce qui fait 3 combinaisons~~
  - ~~4 avec 3 cartes -> la carte n'a plus qu'une position possible à chaque fois ce qui fait une combinaison~~
  - ~~On a donc au total ``4 * 6 + 6 * 3 + 4 * 1 = 46``, 46 possibilités pour le switch case, ce qui fait beaucoup pour juste vérifier un affichage par défaut~~
  ~~|-> En résumé: dans la table collection, il  y a un champ pour l'affichage par défaut qui contient 8 chiffres (sous forme binaire): ``1000 0100``, le premier paquet de 4 représente le recto, et le deuxième paquet le verso; le premier chiffre de chaque paquet représente l'élément 1 et ainsi de suite jusqu'à 4 ~~


  - ~~L'autre possibilité est une array json~~ 


~~Si une carte fait partie de plusierus colllections, l'affichage apr défaut de la collection prend le dessus sur celui de la carte~~
~~Est ce qu'une carte peut faire partie de plusieurs collections ?: non -> l'idéal ce serait une seule collection par cartes (ça permettrait d'avoir les options générique attribué à la collection (genre les labels)) ~~
~~Les collections ont un format , les cartes pas besoin peut etre -> oui pas besoin ?~~

~~Faire 2 tables ? une pour les cartes privées ? et une pour les cartes publiques ? les cartes privés serait propre à chaque personne, et si elles proviennent d'une carte publique aurait un lien vers leur carte publique originnelle, ce qui permet de savoir au sein d'une collection issue d'une collection publique quelle carte il manque par rapport à la collection publique, ou alors les cartes pourraient avoir des relation interne dans une seule table (genre pour une carte privée: public_card_id réfère à l'id d'une autre carte qui elle est public)~~, ~~on peut aussi faire pour toutes les cartes une table qui reprend les infos qui change pour chaque utilisateur (chaque carte serait donc unique et dupliquée pour chaque user), et une table générique avec les infos visuelles (comme le contenu), dans ce cas si la carte est privée, elle est unique et possède une seule entrée dans la table des stats, et si elle est publique elle est unique dans la table contenu mais possède plusieurs entrées (une par user) dans la table stat~~

 ~~si il y a des images possibles dans les éléments de carte on ne stocke que l'url en bdd et les images dans un dossier uploads~~

~~les collections doivent avoir:~~
- ~~le format ? :~~
  - ~~si le format est unique pour une collection, alors toutes les cartes créées dans cette collection ont automatiquement le meme affichage par défaut~~
  - ~~Si la collection possède des formats mélangés ?? -> non impossible désormais~~
  - ~~Le label pour chacun des 4 éléments~~
- ~~la note moyenne de la collection (vide si non publique)-> non passe dans la table note~~
- ~~un statut privé/public~~

+ Nom: Flexcards ? sans doute que non, c'est déjà le nom d'une société portuguaise qui n'a pas vraiment de rapport, ils impriment juste des cartes genre cartes de visite

- penser à l'internationalisation: faire site en anglais, mettre une version francaise au moins ?
  - i18next ?



penser à attribuer les phases aux taches

nosql pour la bdd ?


~~les cartes doivent avoir:~~
- ~~l'id de la collection à laquelle elles appartiennent~~
- ~~le contenu de l'élément 1~~
- ~~le contenu de l'élément 2~~
- ~~le contenu de l'élément 3~~
- ~~le contenu de l'élément 4~~
- ~~l'affichage par défaut de la carte (ou à mettre plutot dans collection ?) -> sous forme de paquets en binaire voir plus haut~~
- ~~Le rang de la carte~~



~~Pour les tables des cartes il faudrait peut etre:~~
-~~ Une table pour le contenu de la carte et les éléments qui dans le cas d'une collection publique ne pourront être changé que par l'auteur~~
- ~~Une table pour les statistiques de la carte lié à chaque utilisateur, les deux tables sont en relation: ainsi on a deux cas:~~
  - ~~Cas 1: une carte privée unique pour un utilisateur: il a donc le contenu de sa carte sur une table et les statistiques qui y sont liées dans une autre table relié par l'id de la carte, la table statistique est relié à l'user par le user_id~~
  -~~ Cas 2: un utilisateur utilise une collection publique pour ses sessions: la table contenu de la carte, ne peut pas être modifié par ses actions, en revanche ses actions peuvent influer sur son entrée pour cette carte dans la table statistiques~~

~~Dans les collections publiques, pour une carte donnée, un utilisateur qui n'est pas l'auteur:~~
  - ~~peut influer sur (ce qui est dans la table stats de la carte, relié par l'user_id à l'user et par le card_id à la carte)~~:
    - ~~Son taux de réussite pour cette carte et le niveau de difficulté pour lui~~
    - ~~Le rang qu'il donne à la carte (puisque le rang est une info privée)~~
    - ~~le nombre de passage qu'il a fait sur cette carte~~
    - ~~Sa priorité d'apprentissage pour cette carte~~


~~En bdd on stocke:~~
+ ~~Pour les stats d'une carte:~~
  - ~~L'id de cette version de la carte (primary_index)~~
  - ~~L'id de la carte dans la table contenu (card_content_id)~~
  - ~~L'id de l'utilisateur~~
  - ~~Les résultats de validation (sous forme 110011100001...)~~
  - ~~Le rang actuel~~
  - ~~La priorité d'apprentissage (calculé par les différents poids et recalculée à chaque fois qu'on valide une carte)~~
  - ~~Le nombre de passage n'a pas besoin d'etre enregistré en bdd, puisqu'il suffit de compter la taille de la chaine des résultats de validation~~
  - ~~Le taux de réussite moyen n'est pas stocké non plus ? car il est calculé de la manière suivante: compter les ``1`` dans la chaine des résultats de validation et en divisant par le nombre total d'itérations sur la carte (longueur de la chaine) puis en transformant en pourcentages~~
  - ~~taux de réussite récent pareil pas nécesaire de le stocker puisque facilement calculable (il suffit du coup de faire une fonction)~~
  - ~~par contre on pourrait stocker le niveau de difficulté (pour faciliter la récupération d'infos quand on doit choisir que les cartes avec un certain niveau de diffculté)~~

  ~~Non en fait il faudrait que toutes les infos soient recalculés (si nécessaire) à chaque validation et enregistrée en bdd, car on peut parfois en avoir besoin dans des situations où on ne récupère pas toutes les données des cartes, par exemple quand on veut seulement afficher le nombre total de cartes pratiquées, il faudrait, de plus pour le calcul du taux de priorité ce sera plus simple: en gros quand on valide une carte, on récupère ces anciennes données , on recalcule le taux de priorité~~

~~S'il n'y a pas assez de cartes dans une collection, exemple on en veut 10 mais la collection choisie n'en a que 5, alors on présente les 5 puis on affiche un message pour indiquer que la session prend fin prématurément du à une absence de cartes~~

+ ~~Pour le contenu d'une carte:~~
  - ~~Id de la carte (primary_index)~~
  - ~~Id de la collection dans la table collection version publique~~
  - ~~Contenu du label 1~~ ~~(les contenus doivent pouvoir stocker n'importe quel type de donnée. Les images vidéos et autres médias sont stockés sous forme de lien vers leur emplacement, voir pour faire en sorte que les utilisateurs puissent linker vers une image sur une banque d'image par exemple)~~
  - ~~Contenu du label 2~~
  - ~~Contenu du label 3~~
  - ~~Contenu du label 4~~

+ ~~Pour une collection version générale (publique, fonctionne aussi pour une privée), dans le cas où cette collection est utilisée de manière publique par un utilisateur ces éléments sont ceux qu'il ne peut donc pas modifier.~~
  -~~ Id de la collection (primary index)~~
  - ~~Id du créateur/auteur principal de la collection~~
  - ~~Id des auteurs auxiliaires (vide si privée)~~
  - ~~Nom de la collection~~
  - ~~Description de la collection~~
  - ~~Difficulté estimée (vide si privée)~~
  - ~~popularité (définie par le nombre de fois où quelqu'un a cliqué sur utiliser en privé ou utilser en public, mais pas par les transfert d'une utilisation publique vers une privée) (vide si privée)~~
  - ~~Liste des ids de catégorie de la collection (relation avec la table des catégories)~~
  - ~~langue des labels de la collection (permet de trier comme pour les catégories, devrait donc être un select avec tous les langages habituels dans les applis)~~
  - ~~Collection parente: Id ?? null/0 -> on se sert de ce champ pour faire une relation interne: parent hasMany Children, et les collections children hasOne parent, si 0 alors pas de relation~~
  - ~~Tag de la collection (public/private)~~
  - ~~Statut de la collection (active/inactive, active par défaut)-> ne peut etre changé que pour les collections publiques, car les collections privées peuvent etre supprimées~~
  - ~~Intitulé du label 1~~
  - ~~Intitulé du label 2~~
  - ~~Intitulé du label 3~~
  - ~~Intitulé du label 4~~
  - ~~Disposition par défaut des éléments (chaine binaire format ``0001 0010``)~~
  - ~~Checksum: 4 slugs d'intitulé de label ? pour vérifier si les libellés d'éléments sont identiques et donc peuvent permettre à l'user de choisir quels éléments il met sur le recto et le verso dans le cas d'une utilisation de plusieurs collections en même temps~~

~~La création avancée consiste en un bouton afficher plus d'options sur la création de base (création rapide)~~

~~Pour la création en remplissage en masse~~
~~on a 10 groupe de champs avec à chaque fois les 4 champs pour les éléments 1,2,3,4 (ou moins si on a choisit moins d'éléments), + un champ curseur avec 1 en valeur par défaut pour le rang~~


~~Algo pour la priorité d'apprentissage, elle doit etre défini par divers éléments qui ont chacun un poids:~~
- ~~Plus la priorité d'apprentissage est un nombre élevé plus on nous repropose la carte souvent~~
- ~~Les cartes devrait avoir une priorité d'apprentissage soit égale à 0 et pouvant etre négative (sans doute le mieux mais attention aux multiplications, les poids multiplicateurs ne doivent pas pouvoir etre négatif, autrement il risquerait d'y avaoir des passage soudain du négatif au positif pour la priorité) ``poids de base = 0``, les nombre seront sujet à rééquilibrage, et peuvent de plus etre changés dans les options) soit égal à un grand nombre et pouvant monter de part et d'autre de ce nombre~~

~~- Nombre de passage: le nombre de passage doit avoir une grande influence sur la priorité, l'objectif étant qu'on nous repropose pas toujours la meme carte à chaque session: pour cela il faudrait donc soustraire ce poid à la priorité à chaque fois qu'on passe sur une carte (comme ça les cartes qui n'ont pas encore été vu gardent le meme poids, les cartes vues baisse en priorité): ``poids = -1 à chaque passage``~~

~~- taux de réussite moyen: ce poid doit etre aussi une soustraction/addition, au dessus d'une valeur pivot (quand on réussit plus qu'on échoue) plus ce taux de réussite est élevé plus on soustrait une grosse valeur, en dessous d'une valeur pivot (quand on échoue plus qu'on réussit) plus le taux est bas plus on ajoute une grosse valeur (pour que la carte soit souvent proposée) ``si taux réussite > pivot(50%) alors poids = -2 ; si taux réussite <= pivot(50%) alors poids = +2``~~
- ~~taux de réussite récent: meme chose que le taux de réussite moyen mais ses limites de poids doivent etre plus extreme que le taux moyen, car les résultats récents doivent avoir plus de poids dans le calcul: ``si taux réussite récent > pivot(50%) alors poids = -5 ; si taux réussite récent <= pivot(50%) alors poids = +5``~~
~~- rang: ~~
  - ~~Si l'utilisateur souhaite que ce soit le rang 5 qui soit proposé plus souvent au lieu du rang 1 il lui suffit d'inverser les noms (appeler le rang 5 rang 1 et inversement), donc le rang compte toujours de la meme façon: plus le rang est élevé, plus la carte doit etre proposé rarement (le rang 5 est supposé etre le rang où on maitrise la carte), ce poid ne doit pas etre trop puissant non plus, idéalement meme si un utilisateur estime la connaitre, si en réalité il échoue tout le temps à cette carte, il faut quand meme que l'appli puisse lui proposer en fonction de son taux de réussite( de toute façon l'user peut choisir de faire des sessions par rang si vraiment il ne veut pas d'un rang): si poid est négatif (= on la connait bien) après calcul des autres poids ``rang 5 = /1, rang 4 / 1.25, rang 3 = /1.50 , rang 2 = /1.75, rang 1 = / 2``, en revanche si poids est positif (donc on ne la sait pas très bien) alors on a ``rang 5 = * 1, rang 4 = *1.25, rang 3 = *1.50 , rang 2 = *1.75, rang 1 = *2``: exemples:~~
    - ~~test 2: si on a une carte avec un poid calculé (avant d'appliquer le rang) de ``-6`` (donc elle ne doit pas etre proposé trop souvent) et une autre avec un poid de ``+8`` elle doit etre proposé plus souvent car on ne la sait pas trop, il faut que le rang influe sur le poid en fonction du rang: le rang devrait réduire le poid si on la connait bien, et l'atténuer si on ne connait pas trop, alors que le rang 1 devrait etre plus puissant que le 5, donc la carte ``-6`` si situé au rang 1 devrait être un peu ignoré, si situé au rang 5 elle devrait être plus ignorée qu'au rang 1 (donc etre encore plus inférieur à -6), pour la +8: au rang 5 on veut que malgré le fait qu'elle soit sue de la meme manière, elle soit moins proposée (car on est supposé plus la savoir), donc dans ce cas on aurait -6 et +8 pour le rang 5, et -3 et +16 pour le rang 1, la carte sera donc bel et bien moins proposée au rang 5, il s'agit ainsi de donner à l'utilisateur le choix de déterminer quelle carte il veux plus souvent puisque si une carte qui est arrivé automatiquement au rang 5 est selon lui pas si maitrisée, il peut choisir de la rétrograder au rang 1 pour lui donner plus de poids~~
    ~~Est-ce qu'il faudrait réinjecter à chaque fois l'ancien calcul de priorité dans le nouveau ? -> probablment que non, car on a déjà la fréquence d'apparition des cartes définie par le poid du nombre de passage~~
    - ~~test 1 (abandonné) une carte de poid ``-4`` (après calcul des autres poids) aura donc un poid de ``2*-4=-8`` du au rang 1 et sera donc moins proposée que les autres cartes rang 1, alors qu'une rang 1 avec poids de ``3`` aura donc un poids final de ``3*2=6`` et sera donc plus proposé, problème si ces memes cartes avec les meme poids étaient au rang 5 on aurait: ``0.5*-4`` = ``-2`` alors qu'elle est rang 5, elle serait donc proposé plus que la rang 1 donc avec le meme taux d'echec qu'une rang 1 on aimerait qu'elle soit quand meme présentée moins souvent qu'une rang 1, définie comme étant moins sue , est ce que ce serait pas ce qu'on souhaite du coup ? les autres poids gèrent la partie réel savoir, de base si une rang 5 a le meme taux qu'une rang 1, cela signifie que l'user ne la sait finalement pas tant que ça, c'eest peut etre du coup pertinent que l'app lui propose plus qu'une rang 1 qu'il sait en pratique de la meme manière, et les autres poids s'occuperont du reste ?~~ 
    

  ~~On pourrait modifier le poid final en: arrondissant à 2 décimales après la virgule puis en multipliant par 100 afin de ne pas stocker des nombres à virgule~~
  -~~ vu qu'il est possible de désactiver la prise en compte du rang dans la priorité, quand il est désactivé: soit on ajoute/soustrait 0 soit on multiplie/divise par 1~~

~~Est-ce que le rang doit vraiment pouvoir etre désactivable ?  il vaudrait peut etre mieux simplement le mettre en automatiqe pour ceux qui veulent pas s'embeter avec ça, ou alors quand on désactive le rang, il s'agit d'une simple option à cocher, si elle est coché alors le poids du rang est soit de 0 s'il doit s'ajouter soit de 1 s'il doit etre un multiplicateur, comme ça il est présent mais n'influe pas sur le calcul -> oui c'est ce qu'on voulait à la base, donc le rang n'est en réalité pas vraiment désactivable avec une case option mais son curseur de poid peut etre mis à 0 (ou 1 si c'est un multiplicateur)-> du coup le mieux case à cocher dans les paramètres pour laisser le rang influer sur la priorité, si on coche cette case ça met tous les poids de rang à 1~~

~~Si un élément a un label mais que pour une carte il n'y a pas de contenu comment on fait , exemple dans le cas où on a rajouté des labels après pour des nouvelles cartes ? est-ce qu'on affiche "pas d'entrée pour ce libellé" ? ou on laisse vide ?, ce qu'on peut faire c'est ne pas afficher le libellé si il n'y a pas de contenu, de cette manière si on a rajouter un libellé, les cartes qui n'ont pas de contneu pour ce libellé n'auront pas de problème d'affichage~~

~~Pour la popularité de la collection il n'y a pas besoin de la stocker ?, quand on cherche à l'obtenir on peut simplement regarder dans la liste des collections perso combien utilise l'id de la collection publique (problème si quelqu'un l'a passé en privé ce ne serait pas répercuté ?): du coup la popularité calcule uniquement ceux qui l'utilisent en mode publique ? ou quand on utilise en mode privé il faudrait aussi rajouter un champs pour ça ?: solution:~~
  - ~~Quand on clique sur utiliser en privé directement: une fois que la collection a été dupliqué et nous est donné en privé on ajoute 1 au compteur d'utilisation~~
  - ~~Si on choisit de l'utiliser en public, une table perso nous est créée pour cette collection et donc on ajoute 1 au compteur d'utilisations~~
  -~~ Si on utilisait déjà en public et qu'on passe en privé, rien ne change (puisque notre utilisation est déjà comptabilisée) ~~
  - ~~Donc en résumé quand on est dans le cas où l'appli crée une nouvelle table perso pour une collection, on ajoute 1 au compteur de popularité, sachant que quand on passe d'une utilisation publique à une privée, seul l'id de la collection générique est changée dans la collec perso on n'en a pas recréer donc il n'y a pas de problème~~



+~~ Pour une collection version perso (partie propre à chaque utilsateur, donc soit correspondant aux éléments propre à un user pour une collection publique, soit ces meme éléments pour sa collec privée), dans le cas où elle est utilisé de manière publique, il s'agit des éléments qu'il peut modifier (sauf les Id bien sur qui servent pour les relations):~~
  - ~~Id de la version privée de la collection (primary index)~~
  - ~~Id de la collection d'origine (pour avoir toute les infos)~~
  - ~~Nom donné au rang 1 pour cette collection~~
  - ~~Nom donné au rang 2 pour cette collection~~
  - ~~Nom donné au rang 3 pour cette collection~~
  - ~~Nom donné au rang 4 pour cette collection~~
  - ~~Nom donné au rang 5 pour cette collection~~


~~Table des notes: ~~
  ~~- Id de la collection (générique) notées~~
  ~~- Id de l'utilisateur qui a noté~~
  ~~- note pour la première question ~~
  ~~- note pour la deuxième question ~~
  ~~- note pour la troisième question ~~
  ~~- note générale donnée par cet utilisateur à cette collection~~

~~Table des catégories:~~
  - ~~Id de la catégorie~~
  - ~~Nom de la catégorie~~
  - ~~Catégorie parente ( 1id )~~
  - ~~Catégories enfantes ( plusieurs ids possibles )~~

~~Table des utilisateurs:~~
  - ~~Id de l'utilisateur~~
  - ~~email~~
  - ~~password~~
  - ~~Nom d'utilisateur~~
  - ~~Role: admin, modo, utilisateur connecté, auteur?? (ou alors auteur n'est pas un rôle, on recherche dans la table des collections, les collections avec le tag public et l'id de cet utilisateur dans auteur, auteur principal ou auxiliaire)~~

~~Table des paramètres généraux et de session (par défaut):~~
~~+ id~~
~~+ User_id ~~
~~+ paramètre de session par défaut (objet JSon ou décomposer en plusieurs champs ?)-> on décompose en plusieurs champs, ces paramètres sont ceux présentés par défaut si l'utilisateur ne change rien, ensuite à chaque fois qu'il fait de nouveaux réglages pour une session , ces nouveaux paramètres remplacent les anciens, liste des paramètres de session (avec leur valeur par défaut):~~
~~  - Liste des collections utilisées: array('')-> par défaut sa première collection créée est ajouté à l'array~~
~~  - Niveau de difficulté des cartes choisies: defaut:all~~
~~  - Rang des cartes: defaut:all~~
~~  - Nombre de cartes par session: defaut:10~~
~~  - Côté à afficher en guise de question: defaut:recto~~ ~~(note les éléments à afficher sur ce recto/verso sont défini à l'échelle d'une collection, par son affichage par défaut)~~
+ ~~paramètre généraux (objet JSon)-> on décompose en plusieurs champs, en revanche les paramètres graphiques pourraient etre en json (un peu comme une sorte de thème.json, l'utilisateur pourrait customiser, et on récupère pour lui en fonction des ses customisations) (est-ce qu'on remplacerait pas plutot par des cookies ?), liste des paramètres généraux, leur valeur par défaut et les valeurs limites possible:~~
  - ~~view_count_weight: 1,~~
  - ~~average_success_rate_weight: 2,~~
  - ~~recent_success_rate_weight: 5,~~
  - ~~rank_five_weight: 1,~~
  - ~~rank_four_weight: 1.25,~~
  - ~~rank_three_weight: 1.5,~~
  - ~~rank_two_weight: 1.75,~~
  - ~~rank_one_weight: 2,~~
  - ~~recent_success_rate_range: defaut:5, valeurs limites:3 -- (pas:1) --> 10~~
  - ~~classement automatique des rangs est activé: defaut:true~~
  - ~~valeur pour passage au rang supérieur: defaut:(>=)100%~~
  - ~~valeur pour passage au rang inférieur: defaut:(<)25% ~~
  - ~~Aspect visuel des cartes (est-ce qu'on met ça pour les collections plutot ? comme ça on peut custom chaque collection séparément-> non ça ferait beaucoup d'éléments en bdd, pour un truc que les gens utiliseraient pas tous) (objet JSON): exemple (à revoir plus tard):~~
  ~~```json~~
  {
    ~~style: [~~
      ~~background-color:"color-value",~~
      ~~text-color:"color-value",~~
      ~~font-size:"size-value",~~
    ]
  }
  ~~```~~


~~Pour les catégories comment ça marche entre public et privé ?-> peut etre simplemeny faire des catégories publiques, pas de possibilité d'en faire des privées ?-> oui ce sera mieux~~

~~Dans le cas ou une collection publique est utilisé de manière privée, elle est alors dupliquée et l'utilisateur se voit attribuer une nouvelle collection privée qui lui est propre basée sur la version publique, mais il peut alors la modifier comme bon lui semble, cette nouvelle version étant désormais séparée de la version publique, il faudra penser à récupérer toutes les éventuelles statistiques et rangs liées aux cartes de cette collection pour les attribuer à la nouvelle version privée (juste changer les ids ?), donc c'est à dire que dans ce cas:~~
  - ~~On crée une nouvelle collection dupliquée de l'ancienne (table collec générale), elle passe en privée, on récupère toutes les collections enfant si nécessaire et on fait la meme~~
  - ~~la table card_content voie aussi ses entrées dupliquées, les nouvelles entrées récupèrent désormais l'id de la nouvelle collection créée~~
  - ~~Dans les table card stats et collec perso, on change alors l'id de la collection d'origine par celui de la nouvelle (ainsi toutes les stats sont gardées)~~

~~Il faut prévoir un système de demande pour passer éditeur, c'est à dire qu'un utilisateur peut faire une demande pour passer éditeur secondaire sur une collection,  l'éditeur principal reste seul maitre à bord, donc:~~
- ~~si la collection est passé inactive par lui, les auteurs secondaires sont désatribués de la collection, il ne peuvent plus la modifier~~
- ~~s'il souhaite quitter l'édition de cette collection un choix s'offre à lui pour sélectionner celui qui reprend le role d'auteur principal~~
- ~~s'il supprime son compte: l'auteur secondaire le plus ancien (donc le premier dans l'array des ids, faire attention à la manière dont j'ajoute les ids, afin que cette ordre d'ajout ne change jamais) devient automatiquement l'auteur principal~~
-~~ rappel une collection publique ne peut jamais disparaitre~~

~~Note: passer une collection privée en version publique est possible, il suffit alors de mettre le tag de private à public, en revanche on ne peut plus la repasser dans l'autre sens (impossible de passer une collection de public à privé), si on souhaite à nouveau passer en privé, il faut alors utiliser en privé (et cela dupliquera, une version publique et une privée)~~

~~Note: le système de demande pour passer auteur, et le système pour passer une collection utilisé en public en version privé, ou utiliser une public en privé seront des systèmes avancés, dans la version de base on se concentre déjà sur faire fonctionner: création de collections privées, création de collection publiques, utilisation d'une collection publique, utilisation d'une collection privée, il n'y aura de base pas de passerelle entre les deux, mais le système devrait etre assez maléable pour ajouter facilement ceci plus tard~~

~~Rajouter la possibilité de sauter des rangs ? (exemple n'utiliser que 1, 3 et 5 et skip les 2 et 4, ou meme plus maléable en choisissant le nombre de range voulu entre 2 et 5): pour le stockage ça ne changerait rien, il suffit simplement d'ajouter dans le calcul du passage automatique au rang supérieur de prendre en compte l'option des rangs utilisés, et dans la jauge de n'afficher que le nombre nécessaire -> non~~

~~Quand on utilise une collection en version publique, il faut qu'on puisse la passer en mode privée (l'inverse n'est pas possible) ainsi si un jour la collec publiqe passe en inactive, on peut la prendre en privé pour la modifier~~

~~Question: que se passe-t-il si on prend deux collections qui ont le meme checksum mais pas la meme disposition par défaut ?, le problème dans ce cas est que l'appli nous laisse choisir ce qu'on met au recto et ce qu'on met au verso, car les labels sont les même, mais en revanche si on choisit de prendre l'affichage par défaut sans rien changer, les deux collections n'afficheront pas les meme éléments au cours de la session:~~
- ~~Solution 1: on fait une double vérif: ~~
  + ~~on check d'abord le checksum pour vérifier si l'user aura le droit de choisir ce qui s'affiche au recto et au verso:~~
    - ~~si oui on lui affiche le formulaire de choix des~~ labels, 
    -~~si non on ne l'affiche pas et il peut uniquement choisir recto ou verso~~
  + ~~puis on vérifie la disposition par défaut (recto/verso)~~
    ~~- Si le checksum est le meme mais la disposition n'est pas la même pour les deux collections: alors on utilise l'affichage par défaut de la première collection pour les deux~~
    - ~~Sinon les cas restants sont: ~~
      - ~~Le checksum est le meme et la disposition est la meme, donc pour toutes les cartes on peut prendre l'affichage par défaut (vu que c'est le meme)~~
      - ~~le checksum n'est pas le meme, dans ce cas les labels ne seront de toute façon pas identique et les affichages par défaut s'appliquent alors pour toutes les cartes (l'user peut quand meme choisir si on lui ontre le recto ou le verso mais pas ce qu'il y a dessus)~~
      - ~~Donc dans ces deux cas restants on peut prendre l'affichage par défaut propre aux deux collections~~


      ~~question pour l'affichage : comment l'affihcage par dfaut change:~~
        1.~~ on peut le chager quand on modifie une collection~~ 
        2. ~~il change en fonction des paramètres de session, par exmeple si on a 0100 1000 avant une session et que durant cette session on choisit d'afficher 0101 1010 alors le nouvel affichage devient l'affichage par défaut:~~
          - ~~avantage l'utilisateur n'a rien à faire ce sera ces précédentes sessions qui définiront l'affichage par défaut~~

~~Question: que se passe-t-il quand on utilise à la fois des collections privées et publiques dans une session ? :~~
- ~~le plus simple serait de mettre le mode édition publique pour tout dans ce cas, donc on ne peut changer que le rang des cartes y compris pour nos cartes privées~~

~~idée: supprimer le concept de format: les collections n'ont plus qu'un format possible (exemple description, caractère, traduction), si un utilisateur souhaite avoir plusieurs format dans une meme collection (exemple schéma->explication et terme->définition), il lui suffit de créer les 4 éléments, (schéma, définition, explication, terme) puis lors d'une session il en met deux au recto et deux au verso (exemple schéma et terme au recto, et explication, définition au verso, ainsi les cartes ne sont pas obligées d'avoir tous les éléments, les éléments sont donc considérés comme ayant un ``et/ou`` au lieu d'un ``et``), en plus de ça on pourrait éventuellement laisser le choix à l'user de faire des sessions avec plusieurs collections mélangées (ce qui reviendrait au meme mais rendrait la création de collection plus simple en forçant un seul format)-> idée retenue, car de plus, avec le concept de colections sous collections on peut déjà facilement émuler les formats (exemple faire une collection physique/chimie avec une sous collection ``schéma/explication`` et une autre ``terme/définition``), comme ça en plus on peut choisir de faire soit uniquement une sous collection, soit la collection entière ou même plusieurs collection, ce qui signifie: facilité de stockage en bdd, facilité de création des collections et usage plus flexible pour l'user~~


~~Les phases du projet:~~
+ ~~Phase 1:  ce qu'il faut au projet pour fonctionner de manière basique:~~
  - ~~Création/modification de collections publiques~~
  - ~~Création/modification de collections privées~~
  - ~~Création/modification de cartes au sein des collections~~
  - ~~Utilisation des collections publiques~~
  - ~~Création d'utilisateur~~
  - ~~Modifications des paramètres~~
  - ~~Calcul de priorité de présentation des cartes~~


+ ~~Phase 2: les éléments qui seraient intéressant à ajouter mais peuvent être amenés dans le projet sur le tard (voir après l'examen):~~
  - ~~Système de signalement/réclamation~~
  - ~~Role modérateur~~
  - ~~Capacité de nommer des auteurs secondaires~~
  - ~~Possibilité de transformer une collection publique en collection privée~~
  - ~~succès~~
  - ~~Possibilité d'ajouter des images dans les éléments~~
  - ~~Customisation de l'interface visuel~~
  - ~~Sytème de notes~~
  - ~~Requetes d'ajout de catégories~~
  - ~~Filtres de recherche dans la liste des collections publiques~~
  - ~~Graphiques de progression sur les pages des collections et des cartes~~
+ ~~Phase 3: les éléments bonus (tel que l'ajout de fonctions de dessin), qui seront peut etre mis en place, mais seulement à l'avenir si le projet fonctionne déjà correctement de base:~~
  - ~~Planification de sessions régulières~~
  - ~~Possibilité de dessiner directement dans l'application~~
  - ~~Possibilité de faire des dessins libre pendant les sessions d'apprentissage~~
  - ~~fichiers audio~~
  - ~~portage en version appli, avec sauvegarde sur la machine de l'utilisateur~~
  - ~~exportation des cartes au format JSON~~
  - ~~impresssion au format papier~~


